import java.io.*;
import java.util.*;

class RopeProblem {
	// Vertex of a splay tree
	class Vertex {
		char symbol;
		int size;  // number of vertices in the subtree with this vertex as root
		Vertex left;
		Vertex right;
		Vertex parent;

		Vertex(char symbol, int size, Vertex left, Vertex right, Vertex parent) {
			this.symbol = symbol;
			this.size = size;
			this.left = left;
			this.right = right;
			this.parent = parent;
		}
	}

    // this updates the size field of v and the parent fields of its children
    void update(Vertex v) {
        if (v == null) return;
        v.size = 1 + (v.left != null ? v.left.size : 0) + (v.right != null ? v.right.size : 0);
        if (v.left != null) {
            v.left.parent = v;
        }
        if (v.right != null) {
            v.right.parent = v;
        }
    }

    // Implementation of Zig; v is the node with lowest height
    // Zig: rotation of 2 nodes
    void smallRotation(Vertex v) {
        Vertex parent = v.parent;
        if (parent == null) return;  // no need to rotate for just 1 node
        Vertex grandparent = v.parent.parent;
        if (parent.left == v) {
            Vertex m = v.right;
            v.right = parent;
            parent.left = m;
        } else {
            Vertex m = v.left;
            v.left = parent;
            parent.right = m;
        }
        update(parent);
        update(v);
        v.parent = grandparent;
        if (grandparent != null) {
            if (grandparent.left == parent) {
                grandparent.left = v;
            } else {
                grandparent.right = v;
            }
        }
    }

    // Implementation of Zig-zig & Zig-zag; v is the node with lowest height
    // Zig-zig: the node, its parent and grandparent are on the same side
    // Zig-zag: the parent and grandparent are on the opposite side
    void bigRotation(Vertex v) {
        if (v.parent.left == v && v.parent.parent.left == v.parent) {
            // Zig-zig
            smallRotation(v.parent);
            smallRotation(v);
        } else if (v.parent.right == v && v.parent.parent.right == v.parent) {
            // Zig-zig
            smallRotation(v.parent);
            smallRotation(v);
        } else {
            // Zig-zag
            smallRotation(v);
            smallRotation(v);
        }
    }

    // Makes splay of the given vertex and returns the new root.
    Vertex splay(Vertex v) {
        if (v == null) return null;
        while (v.parent != null) {
            if (v.parent.parent == null) { // Case for Zig
                smallRotation(v);
                break;
            }
            bigRotation(v);  // otherwise Zig-zig or Zig-zag
        }
        return v;
    }

    // used to store pairs of results generated by the following methods
    class VertexPair {
        Vertex left;
        Vertex right;
        VertexPair() {
        }
        VertexPair(Vertex left, Vertex right) {
            this.left = left;
            this.right = right;
        }
    }

    // this finds and returns the root of the smallest subtree containing k smallest nodes;
    //  here "smallest nodes" means nodes with symbols with smallest indices
    // note: k is 1-based
    // 
    // this returns null (the next value) if k > total number of nodes in the tree
    Vertex findSmallestSub(Vertex root, int k) {
        int leftSize;  // size of the left subtree (values of nodes < values of root)
        Vertex pointer = root;
        while (pointer != null) {
        	leftSize = pointer.left != null ? pointer.left.size : 0;
        	if (k == 1 + leftSize) {  // root found
        		break;
        	} else if (k < 1 + leftSize) {  // required root is in the left subtree
        		pointer = pointer.left;
        	} else { // k > 1 + leftSize, some parts of the right subtree should also be considered
        		pointer = pointer.right;
        		k -= 1 + leftSize;
        		// the whole left subtree and the root have been confirmed to be included
        	}
        }
        root = splay(pointer);
        // now pointer (the node with the largest index in the required sequence) is splayed to top
        return pointer;
    }

    // returns result.left: tree with node indices < k; result.right: tree with node indices >= k
    // note: k is 1-based
    VertexPair split(Vertex root, int k) {
        VertexPair result = new VertexPair();
        Vertex findAndRoot = findSmallestSub(root, k);  // node with index k now splayed to top
        if (findAndRoot == null) {  // k > total number of nodes
            return new VertexPair(root, null);
        }
        result.left = findAndRoot.left;
        root = findAndRoot;

        if (result.left == null) {  // no node with index < k; no need to split
            result.right = root;
            return result;
        }


        result.left.parent = null;

        result.right = root;
        result.right.left = null;
        update(result.right);


        return result;
    }

    // all keys in left tree < all keys in right tree (if the trees are not null)
    Vertex merge(Vertex left, Vertex right) {
        if (left == null) return right;
        if (right == null) return left;

        // finds the biggest key in the smaller tree and splayed to top
        while (left.right != null) {
            left = left.right;
        }
        left = splay(left);

        // bigger tree merges to the smaller tree
        left.right = right;
        update(left);

        return left;
    }

    // ***** The following is code that uses splay tree to solve the problem *****

    Vertex root = null;  // root of the splay tree

    // this creates a splay tree for the main string
    void createTree(String s) {
        root = new Vertex(s.charAt(0), 1, null, null, null); // first char. as root of the initial tree
        for (int i = 1; i < s.length(); i++) {
            root = merge(root, new Vertex(s.charAt(i), 1, null, null, null));
        }
    }

    // this is the main operation of the Rope structure: it cuts substring S[i...j]
    //  (i, j are 0-based) from the main string, then inserts it after the k-th symbol
    //  of the remaining string (if k = 0, S[i...j] is inserted in the beginning).
    void cutAndInsert(int i, int j, int k) {
        // cut operation
        VertexPair firstSplit = split(root, i+1);  // left: index < i; right: index >= i
        VertexPair secondSplit = split(firstSplit.right, j-i+2);  // secondSplit.left: S[i...j]
        root = merge(firstSplit.left, secondSplit.right);

        // insert operation
        if (k == 0) {  // substring is inserted in the the beginning
            root = merge(secondSplit.left, root);
        } else {  // substring in inserted after k-th symbol
            VertexPair thirdSplit = split(root, k+1);
            root = merge(merge(thirdSplit.left, secondSplit.left), thirdSplit.right);
        }
    }

    // this outputs the string according to the splay tree using non-recursive inorder traversal
    String inOrderTraversal(Vertex root) {
        if (root == null) return null;
        StringBuffer result = new StringBuffer();  // used to store pieces of the resulting string
        Stack<Vertex> stack = new Stack<Vertex>();
        stack.push(root);

        while(!stack.empty()) {
            Vertex top = stack.peek();
            if (top.left != null) {
                stack.push(top.left);
                top.left = null;
            } else {
                result.append(top.symbol);
                stack.pop();
                if (top.right != null) {
                    stack.push(top.right);
                }
            }
        }

        return result.toString();
    }

	class Rope {
		String s;

		// Replace this code with a faster implementation
		void process( int i, int j, int k ) {
            String t = s.substring(0, i) + s.substring(j + 1);
            // new string without the S[i...j] substring
            s = t.substring(0, k) + s.substring(i, j + 1) + t.substring(k);
            // inserts s[i...j] after the k-th symbol
		}

        void processFast(int i, int j, int k) {
            cutAndInsert(i, j, k);
        }

		String result() {
            s = inOrderTraversal(root);  // if using processFast()

			return s;
		}

		Rope( String s ) {
			this.s = s;

            createTree(this.s);
		}
	}

	public static void main( String[] args ) throws IOException {
		new RopeProblem().run();
	}
	public void run() throws IOException {
		FastScanner in = new FastScanner();
		PrintWriter out = new PrintWriter(System.out);
		Rope rope = new Rope(in.next());
		for (int q = in.nextInt(); q > 0; q--) {
			int i = in.nextInt();
			int j = in.nextInt();
			int k = in.nextInt();
			rope.processFast(i, j, k);
		}
		out.println(rope.result());
		out.close();
	}

	class FastScanner {
		StringTokenizer tok = new StringTokenizer("");
		BufferedReader in;

		FastScanner() {
			in = new BufferedReader(new InputStreamReader(System.in));
		}

		String next() throws IOException {
			while (!tok.hasMoreElements())
				tok = new StringTokenizer(in.readLine());
			return tok.nextToken();
		}
		int nextInt() throws IOException {
			return Integer.parseInt(next());
		}
	}
}
